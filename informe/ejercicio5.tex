\section{Ejercicio 5}

La implementación de $RSDL$ en este trabajo busca reflejar las características más importantes de este algoritmo dentro de un entorno y dinámica de trabajo un tanto simplificado. El resultado es un $scheduler$ que eventualmente otorga los recursos del CPU a todas las tareas (de ahí la característica de $fairness$ que se analiza más adelante y la ausencia de inanición) pero que no obstante las maneja de acuerdo a ciertos niveles de prioridad.\\
\indent La clase $SchedRSD$ cuenta con varias estructuras soporte. Por un lado utilizamos dos vectores correspondientes a las 'escaleras': uno comienza siendo el activo y es allí donde, en cada nivel, se encolan las tareas. Luego de las distintas rotaciones si no quedan más niveles para que las tareas desciendan se las introduce en la segunda escalera. Una vez que no queda ninguna tarea por ejecutar en la activa, se realiza un swap y se resume la ejecución bajo las condiciones iniciales. Adicionalmente se utilizan otros dos arreglos, uno para almacenar la cuota de tiempo asignada para los procesos en determinado nivel y otro para llevar control de la cuota global restante en cada nivel. En cuanto a la información relacionada con los procesos, se decidió utilizar dos diccionarios para guardar, en uno, los procesos bloqueados y el nivel en el que estaban al haber entrado a ese estado y, en otro, los procesos y sus cuotas individuales restantes. Finalmente, al igual que en el scheduler $Round Robin$ se cuenta con un vector de cpus y sus correspondiente arreglos de ticks transcurridos para la tarea actual y de quantum. Es importante aclarar que a diferencia de $RR$ y a pesar de conservar las mismas estructuras aquí no se utiliza el algoritmo como multicore debido a la complejidad de una implementación así.\\
\indent La inicialización del scheduler responde más que nada a cuestiones técnicas, como por ejemplo leer los parámetros y crear las estructuras de manera dinámica, llenar cada nivel con colas vacías, etc. Lo más relevante para destacar es que en principio la cuota global de cada nivel es $0$ ya que su valor estará dado por las cuotas individuales de los procesos que se carguen en cada uno. \\
\indent El siguiente paso consiste en la carga de tareas. Aquí se tomaron varias decisiones que vale la pena comentar. En lo que respecta a la prioridad inicial de una tarea no hay manera de poder determinarla al momento de carga. Tampoco creemos que asignar algún valor aleatorio fuera positivo, pues probablemente se subestimarían tareas con requerimiento de alta prioridad. La conclusión a la que llegamos fue sobreestimar a todas ellas y colocarlas en el máximo nivel de prioridad ($0$). Eventualmente aquellas tareas que se bloquean (es decir que son interactivas) no consumen su tiempo y permanecen en niveles de prioridad altos mientras el resto de las tareas comunes baja. Esto está garantizado en nuestra implementación por el hecho de que el diccionario de tareas bloqueadas recuerda el nivel donde estaba activo el proceso y porque una vez definidas allí las tareas no consumen su cuota ni participan de la rotación de cada nivel. Luego, a la primera tarea cargada se le asigna el cpu mientras que el resto se encolan en el nivel de prioridad correspondiente. Al realizar esta función también reflexionamos sobre qué debería suceder si una tarea fuera cargada en medio de la simulación. A diferencia de un desbloqueo, donde se acentúa y preserva la prioridad de tareas interactivas, una tarea completamente nueva no debería poder ser cargada en un nivel de mayor prioridad al activo en ese momento. Esto podría impactar negativamente en la fluidez y desarrollo del scheduler dado que si hubiera pasado un tiempo considerable y todas las tareas hubieran bajado hasta uno de los últimos peldaños de la escalera, la repentina llegada de una tarea a un nivel alto implicaría un retraso importante en el resto. Luego, decidimos que la prioridad de nuevas tareas durante la ejecución fuera la del nivel activo.\\
\indent Por último resta hablar de la función $tick()$, la cual se encarga del grueso de la lógica de esta técnica de scheduling. A grandes rasgos el mecanismo permanece igual que en el resto de los schedulers: tenemos los tres motivos posibles y en cada uno el comportamiento particular para cada tarea es el mismo: o la tarea termina, o se bloquea, o ejecuta normalmente. En cualquier caso el scheduler debe determinar qué tarea devolver como siguiente y qué hacer con la tarea actual, y es aquí donde aparecen las ideas particulares de $RSDL$. Dependiendo del estado de la cuota del nivel actual, del proceso que está corriendo o del quantum restante habrá muchas maneras de proceder: para el motivo tick, puede que el proceso siga ejecutándose o que su cuota individual haya expirado y deba cambiárselo de nivel. También puede suceder que la cuota global del nivel se haya agotado (debido a nuestra implementación eso necesariamente se superpondrá con el agotamiento del proceso actual, dado que la cuota global es la suma de las cuotas de los procesos corriendo) en cuyo caso se realiza una rotación menor (la cola de procesos se baja de nivel). En caso de que no quedaran más niveles se realiza una rotación mayor, que en el caso de esta implementación implica realizar un swap entre los punteros asignados a ambas escaleras puesto que los procesos ya deberían haber sido encolados en los lugares correspondientes.
